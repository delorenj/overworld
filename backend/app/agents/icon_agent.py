"""Icon Placer Agent for milestone and icon placement on maps.

This agent places icons along the road path generated by the RoadAgent,
with features including:
- Collision detection and avoidance
- Icon library integration
- Priority-based placement ordering
- Grid-based or free placement modes
- Boundary checking for map edges
"""

import logging
from typing import Any, Optional

from app.agents.base_agent import AgentResult, BaseAgent, JobContext
from app.schemas.icon import (
    DEFAULT_SMB3_ICONS,
    AnchorPoint,
    BoundingBox,
    IconCategory,
    IconLibrary,
    IconMetadata,
    IconPlacement,
    PlacementConfig,
    PlacementResult,
    Position,
)
from app.utils.collision import (
    adjust_for_boundary,
    check_any_overlap,
    check_boundary,
    check_road_overlap,
    find_non_overlapping_position,
)

logger = logging.getLogger(__name__)


class IconAgent(BaseAgent):
    """Places milestone icons and decorations along the road.

    This agent takes the road coordinates from RoadAgent and milestone
    data from ParserAgent to place icons at appropriate positions with
    collision avoidance.

    Features:
    - Collision detection between icons
    - Collision detection with road path
    - Boundary checking for canvas edges
    - Priority-based placement (higher priority icons placed first)
    - Support for custom icon libraries
    - Grid-based or free-form placement modes
    """

    def __init__(
        self,
        icon_library: Optional[IconLibrary] = None,
        config: Optional[PlacementConfig] = None,
    ):
        """Initialize the IconAgent.

        Args:
            icon_library: Icon library to use (defaults to SMB3 icons)
            config: Placement configuration (defaults to standard settings)
        """
        super().__init__()
        self.icon_library = icon_library or DEFAULT_SMB3_ICONS
        self.config = config or PlacementConfig()
        self._placements: list[IconPlacement] = []
        self._collisions_avoided = 0
        self._boundary_adjustments = 0

    async def execute(self, context: JobContext) -> AgentResult:
        """Place milestone icons along the road.

        Reads road coordinates and milestone data from the context,
        then places icons with collision avoidance.

        Args:
            context: Job context with agent state

        Returns:
            AgentResult with placed icon data
        """
        # Reset placement state
        self._placements = []
        self._collisions_avoided = 0
        self._boundary_adjustments = 0

        # Get data from previous agents
        # Support both nested (via coordinator test contexts) and direct formats
        road_data = context.agent_state.get("road", {})
        if isinstance(road_data, dict) and "data" in road_data:
            road_data = road_data.get("data", {})

        parser_data = context.agent_state.get("parser", {})
        if isinstance(parser_data, dict) and "data" in parser_data:
            parser_data = parser_data.get("data", {})

        coordinates = road_data.get("coordinates", [])
        milestones = parser_data.get("milestones", [])

        try:
            if not coordinates:
                return AgentResult(
                    success=False,
                    error="No road coordinates available from RoadAgent",
                )

            if not milestones:
                return AgentResult(
                    success=False,
                    error="No milestones available from ParserAgent",
                )

            logger.info(
                f"IconAgent: Placing {len(milestones)} milestones along road "
                f"with {len(coordinates)} coordinate points"
            )

            # Get placement configuration from context options
            self._update_config_from_options(context.options)

            # Sort milestones by priority if enabled
            if self.config.priority_placement:
                milestones = self._sort_by_priority(milestones)

            # Place milestone icons
            placement_result = self._place_milestones(milestones, coordinates)

            if not placement_result.success:
                return AgentResult(
                    success=False,
                    error=placement_result.error_message or "Icon placement failed",
                )

            # Convert placements to output format
            icon_data = self._format_placements(placement_result.placements)

            result_data = {
                "icons": icon_data,
                "icon_count": len(icon_data),
                "collisions_avoided": self._collisions_avoided,
                "boundary_adjustments": self._boundary_adjustments,
                "placement_config": self.config.model_dump(),
                "icon_library": self.icon_library.name,
                "statistics": placement_result.statistics,
            }

            logger.info(
                f"IconAgent: Successfully placed {len(icon_data)} icons "
                f"({self._collisions_avoided} collisions avoided)"
            )

            return AgentResult(
                success=True,
                data=result_data,
            )

        except Exception as e:
            logger.error(f"IconAgent: Placement failed - {str(e)}")
            return AgentResult(
                success=False,
                error=f"Icon placement failed: {str(e)}",
            )

    def _update_config_from_options(self, options: dict[str, Any]) -> None:
        """Update placement configuration from job options.

        Args:
            options: Job options dictionary
        """
        if "min_spacing" in options:
            self.config.min_spacing = float(options["min_spacing"])
        if "use_grid" in options:
            self.config.use_grid = bool(options["use_grid"])
        if "grid_cell_size" in options:
            self.config.grid_cell_size = float(options["grid_cell_size"])
        if "road_buffer" in options:
            self.config.road_buffer = float(options["road_buffer"])
        if "allow_overlap" in options:
            self.config.allow_overlap = bool(options["allow_overlap"])

    def _sort_by_priority(self, milestones: list[dict]) -> list[dict]:
        """Sort milestones by priority (level-based).

        Higher levels (more specific milestones) get lower priority
        so they are placed last and can adjust around more important ones.

        Args:
            milestones: List of milestone dictionaries

        Returns:
            Sorted list of milestones
        """
        # Priority: L0 > L1 > L2 > L3 > L4
        # Lower level number = higher priority
        return sorted(milestones, key=lambda m: m.get("level", 0))

    def _place_milestones(
        self,
        milestones: list[dict],
        coordinates: list[dict],
    ) -> PlacementResult:
        """Place all milestone icons.

        Args:
            milestones: List of milestone data
            coordinates: Road coordinate points

        Returns:
            PlacementResult with all placements
        """
        placements: list[IconPlacement] = []
        errors: list[str] = []
        stats = {
            "total_milestones": len(milestones),
            "successful_placements": 0,
            "failed_placements": 0,
            "by_level": {},
        }

        # Get the milestone icon from library
        milestone_icon = self.icon_library.get_icon("milestone_circle")
        if milestone_icon is None:
            # Use default milestone icon properties
            milestone_icon = IconMetadata(
                id="milestone_circle",
                name="Milestone Circle",
                category=IconCategory.MILESTONE,
                size={"width": 48, "height": 48},
                anchor=AnchorPoint.CENTER,
            )

        icon_width = milestone_icon.size.width
        icon_height = milestone_icon.size.height

        # Distribute positions along the road
        position_indices = self._calculate_position_indices(
            len(milestones), len(coordinates)
        )

        for i, milestone in enumerate(milestones):
            milestone_id = milestone.get("id", f"m{i+1}")
            milestone_title = milestone.get("title", f"Milestone {i+1}")
            level = milestone.get("level", 1)

            # Get base position from road coordinates
            coord_index = position_indices[i] if i < len(position_indices) else -1
            if coord_index < 0 or coord_index >= len(coordinates):
                errors.append(f"No valid position for milestone {milestone_id}")
                stats["failed_placements"] += 1
                continue

            coord = coordinates[coord_index]
            base_position = Position(x=float(coord["x"]), y=float(coord["y"]))

            # Try to find a non-overlapping position
            if self.config.allow_overlap:
                final_position = base_position
                attempts = 1
            else:
                final_position, attempts = find_non_overlapping_position(
                    original_position=base_position,
                    icon_width=icon_width,
                    icon_height=icon_height,
                    existing_placements=placements,
                    road_coordinates=coordinates,
                    config=self.config,
                )

            if final_position is None:
                # Fall back to base position if no valid position found
                final_position = adjust_for_boundary(
                    base_position, icon_width, icon_height, self.config
                )
                self._boundary_adjustments += 1
                logger.warning(
                    f"Could not find non-overlapping position for {milestone_id}, "
                    f"using adjusted base position"
                )
            elif attempts > 1:
                self._collisions_avoided += 1

            # Create the bounding box
            half_width = icon_width / 2
            half_height = icon_height / 2
            bounding_box = BoundingBox(
                x=final_position.x - half_width,
                y=final_position.y - half_height,
                width=icon_width,
                height=icon_height,
            )

            # Create the placement
            placement = IconPlacement(
                id=milestone_id,
                icon_id=milestone_icon.id,
                position=final_position,
                bounding_box=bounding_box,
                label=milestone_title,
                priority=10 - level,  # Higher level = lower priority
                category=IconCategory.MILESTONE,
                data={
                    "number": i + 1,
                    "level": level,
                    "original_position": {"x": base_position.x, "y": base_position.y},
                    "placement_attempts": attempts,
                },
            )

            placements.append(placement)
            stats["successful_placements"] += 1

            # Track by level
            level_key = f"L{level}"
            stats["by_level"][level_key] = stats["by_level"].get(level_key, 0) + 1

        self._placements = placements

        return PlacementResult(
            success=len(errors) == 0 or len(placements) > 0,
            placements=placements,
            total_icons=len(placements),
            collisions_avoided=self._collisions_avoided,
            out_of_bounds_adjusted=self._boundary_adjustments,
            error_message="; ".join(errors) if errors else None,
            statistics=stats,
        )

    def _calculate_position_indices(
        self,
        num_milestones: int,
        num_coordinates: int,
    ) -> list[int]:
        """Calculate evenly distributed position indices along the road.

        Args:
            num_milestones: Number of milestones to place
            num_coordinates: Number of road coordinates

        Returns:
            List of coordinate indices for each milestone
        """
        if num_milestones <= 0:
            return []
        if num_coordinates <= 0:
            return []
        if num_milestones == 1:
            return [num_coordinates // 2]
        if num_milestones >= num_coordinates:
            return list(range(min(num_milestones, num_coordinates)))

        # Distribute evenly
        step = (num_coordinates - 1) / (num_milestones - 1)
        return [int(i * step) for i in range(num_milestones)]

    def _format_placements(
        self, placements: list[IconPlacement]
    ) -> list[dict[str, Any]]:
        """Format placements for output.

        Args:
            placements: List of IconPlacement objects

        Returns:
            List of dictionaries suitable for JSON output
        """
        result = []
        for i, placement in enumerate(placements):
            icon_dict = {
                "number": i + 1,
                "id": placement.id,
                "icon_id": placement.icon_id,
                "label": placement.label,
                "pos": {
                    "x": int(placement.position.x),
                    "y": int(placement.position.y),
                },
                "bounding_box": {
                    "x": int(placement.bounding_box.x),
                    "y": int(placement.bounding_box.y),
                    "width": int(placement.bounding_box.width),
                    "height": int(placement.bounding_box.height),
                },
                "category": placement.category,
                "priority": placement.priority,
                "data": placement.data,
            }
            result.append(icon_dict)
        return result

    def get_placements(self) -> list[IconPlacement]:
        """Get the current list of placements.

        Returns:
            List of IconPlacement objects
        """
        return self._placements.copy()

    def set_icon_library(self, library: IconLibrary) -> None:
        """Set a custom icon library.

        Args:
            library: Icon library to use
        """
        self.icon_library = library

    def set_config(self, config: PlacementConfig) -> None:
        """Set placement configuration.

        Args:
            config: Placement configuration
        """
        self.config = config
